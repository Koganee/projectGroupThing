<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <title>BreakOut</title>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script type="module" src = "index.js"></script>
    <style>
      * {
        padding: 0;
        margin: 0;
      }
    #myCanvas{
        background: #eee;
        position: absolute;
        top:0%;
        left: 30%;
        background-image: url("img\\BreakoutBackground.png");
    }
    #myCanvas2{
        background: #eee;
        position: absolute;
        top:0%;
        left: 30%;
    }
    button {
        display: block;
    }
    #userForm
    {
        position: absolute;
        top:40%;
        left: 30%;
    }
    #fNameL
    {
        position: absolute;
        top:38%;
        left: 30%;
    }  
    @font-face { font-family: GolddenStateSerif; src: url('GoldenStateSerifPERSONAL-Black.otf'); } 
    #gameEnd{
        font-family: GoldenStateSerif;
        position: absolute;
        top:15%;
        left: 39.1%;
        color: red;
    }
    #runButton
    {
        position: absolute;
        top:35%;
        left: 40%;
    }
    #endButton
    {
        position: absolute;
        top:38%;
        left: 40.1%;
    }
    #enterName
    {
        position: absolute;
        top:30%;
        left: 37.1%;
    }
    #enterNameLabel
    {
        position: absolute;
        top:28%;
        left: 37.1%;
        color: red;
    }
    #enterDataButton
    {
        position: absolute;
        top:30%;
        left: 46%;
    }
    </style>
  </head>
  <body>
    <canvas id="myCanvas" width="480" height="360"></canvas>
    <canvas id="myCanvas2" width="480" height="320"></canvas>


    <button id="runButton">Start game</button>
    <button id="endButton">End game</button>
    <button id="enterDataButton" onclick = "saveUserName()">Submit</button> <!--Button that will appear to enter username after game end. -->

    <img src ="img\\BreakoutBlock.png" id = "imgBrick"></img>
    <img src ="img\\BreakoutPrisoner.png" id = "imgPrisoner"></img>
    <img src ="img\\BreakoutPaddle.png" id = "imgPaddle"></img>
    <img src ="img\\BreakoutBall.png" id = "imgBall"></img>

    <input type="text" id = "enterName"/></input> <!--Button that will appear to enter username after game end. -->
    <p id = "enterNameLabel">Save Username:</p>

    <p id = "gameEnd">GAME OVER</p>
    <p id = "fNameL">Enter Username:</p>
    <form id = "userForm">
        <input type="text" name ="fName" id="fName" size = "20">
        <button type="submit" id = "submitName">Submit</button>
    </form>
    <audio controls autoplay>
        <source src="C:\Users\Aaron\Downloads\mha.mp3" type="audio/mpeg">
    </audio> 
    <iframe id = "motivation" width="520" height="315" src="https://www.youtube.com/embed/AlLhMySQTlo" frameborder="0"></iframe>
    <script>
        const form = document.getElementById('userForm');
        form.addEventListener('submit', function(e) {
            e.preventDefault();

            const formData = new FormData(form);
            const data = {};
            formData.forEach((value, key) => (data[key] = value))

            console.log(data);

            axios.post('http://localhost:8080/addUser', data)
            .then(res => console.log(res))
            .catch(err => console.log(err))
            
        });

        function saveUserName()
        {
            const data = {username: document.getElementById('enterName').value};
            console.log(data);
            axios.post('http://localhost:8080/addUser', data)
            .then(res => console.log(res))
            .catch(err => console.log(err))
        }
    </script>






    <script>
        const canvas = document.getElementById("myCanvas");
        const canvas2 = document.getElementById("myCanvas2");
        const gameEndP = document.getElementById("gameEnd");
        const endButtonB = document.getElementById("endButton");
        const enterName = document.getElementById("enterName");
        const enterNameLabel = document.getElementById("enterNameLabel");

        canvas2.style.display="none"; //Hidden by default.
        gameEndP.style.display="none"; //Hidden by default.
        endButtonB.style.display="none"; //Hidden by default.
        enterName.style.display="none"; //Hidden by default.
        enterNameLabel.style.display="none"; //Hidden by default.

        const ctx = canvas.getContext("2d");
        const ctx2 = canvas2.getContext("2d");
        const ballRadius = 10;

        let x = canvas.width / 2;
        let y = canvas.height - 50;
        let dx = 2;
        let dy = -2;

        const paddleHeight = 10;
        const paddleWidth = 100;

        const imgBrick = document.getElementById("imgBrick");
        const imgPrisoner = document.getElementById("imgPrisoner");
        const imgPaddle = document.getElementById("imgPaddle");
        const imgBall = document.getElementById("imgBall");

        let paddleX = (canvas.width - paddleWidth) / 2;
        let rightPressed = false;
        let leftPressed = false;

        let interval = 0;
        let score = 0;
        let combo = 1;
        let paused = false;


        const brickRowCount = 3;
        const brickColumnCount = 5;
        const brickWidth = 75;
        const brickHeight = 20;
        const brickPadding = 10;
        const brickOffsetTop = 30;
        const brickOffsetLeft = 30;

        let flashInterval;
        let flashCount = 0;
        const maxFlashes = 29;
        let lastScoreCheck = 0;

        let gameOverV = false;

        var snd = new Audio("audio\\blockBreak.mp3");
        var sndFail = new Audio("audio\\fail.mp3");
        var sndLoop = new Audio("audio\\loop.mp3");

        let bricks = [];
        createBricks();
        function createBricks()
        {
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: 1 };
            }
        }
        }

        document.addEventListener("keydown", keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);



        function keyDownHandler(e) {
        if (e.key == "Right" || e.key == "ArrowRight") {
            rightPressed = true;
        } else if (e.key == "Left" || e.key == "ArrowLeft") {
            leftPressed = true;
        }

        if ( e.key == "Escape") {
            togglePause();
        }
        }

        function keyUpHandler(e) {
        if (e.key == "Right" || e.key == "ArrowRight") {
            rightPressed = false;
        } else if (e.key == "Left" || e.key == "ArrowLeft") {
            leftPressed = false;
        }
        }
        function collisionDetection() {
            snd.preload = "auto"; 
            for(let c = 0; c < brickColumnCount; c++) {
                for(let r = 0; r < brickRowCount; r++) {
                let b = bricks[c][r];
                var soundCount = 0;
                if(b.status == 1) {
                    if (
                    x > b.x &&
                    x < b.x + brickWidth &&
                    y > b.y &&
                    y < b.y + brickHeight
                    ) {
                    dy = -dy;
                    b.status = 0;

                    snd.play();
                    shakeCanvas(500, 3, canvas); //Shakes Canvas upon block break. (Time, Intensity, CanavsToShake).

                    score++;
                    if(score % 15 == 0) {
                        console.log("Hi");
                        setTimeout(() => {
                            createBricks();
                        }, "3000");
                    }
                    if(score % 5 == 0 && score !== lastScoreCheck) {
                        combo = combo * 2;
                        //dx = dx + 0.5;  //DO NOT UNCOMMENT, GAME WILL BREAK AT SCORE OF 5!!!
                        //dy = dy + 0.5;  //DO NOT UNCOMMENT, GAME WILL BREAK AT SCORE OF 5!!!
                    }
                    if(combo == 2) {
                        //Pause Game Here
                        //togglePause();
                    }
                    lastScoreCheck = score;
                    }
                }
                }
            }
        }
        function drawScore() {
            ctx.font = "16px Arial";
            ctx.fillStyle = "#0095DD";
            ctx.fillText(`Score: ${score}`, 8, 20);
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = "#0095DD";
            //ctx.fill();  //.fill may be removed to remove original basic texture.
            ctx.closePath();
            ctx.drawImage(imgBall, x-10, y-10, 20, 20);
        }
        function drawPaddle() {
            ctx.beginPath();
            //ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
            ctx.rect(paddleX, 310, paddleWidth, paddleHeight);
            ctx.fillStyle = "#0095DD";
            ctx.fill();
            ctx.closePath();
            ctx.drawImage(imgPrisoner, paddleX + 30, 320, 40, 40);
            ctx.drawImage(imgPaddle, paddleX, 310, paddleWidth, paddleHeight + 30);
        }
        function drawBricks() {
        for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
            if (bricks[c][r].status == 1) {
                let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                bricks[c][r].x = brickX;
                bricks[c][r].y = brickY;
                ctx.beginPath();
                ctx.rect(brickX, brickY, brickWidth, brickHeight);
                ctx.fillStyle = "#0095DD";
                ctx.fill();
                ctx.closePath();
                ctx.drawImage(imgBrick, brickX, brickY, brickWidth, brickHeight);
            }
            }
        }
        }

        function draw() {
        if (gameOverV) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBricks();
        drawBall();
        drawPaddle();
        drawScore();
        collisionDetection();

        if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
            dx = -dx;
        }
        if (y + dy < ballRadius) {
            dy = -dy;
        } 
        else if (y + dy > 320 - ballRadius && y + dy < 320) //Kinda complicated but this allows the ball to bounce off the paddle only when it is at the paddle level.
        {
            if (x > paddleX && x < paddleX + paddleWidth) 
            {
                if ((y = y - paddleHeight)) 
                {
                    dy = -dy;
                }
            } 
            
        }
        if(y == canvas.height) //Automatic endgame.
        {
            gameOverV = true;
            flashScreenDeath();
            showEnterUserName();
            shakeCanvas(500, 10, canvas2); //Shake canvas upon game over. (Time, Intensity, CanavsToShake).
            
            clearInterval(interval); // Needed for Chrome to end game
        }

        if (rightPressed && paddleX < canvas.width - paddleWidth) {
            paddleX += 7;
        } else if (leftPressed && paddleX > 0) {
            paddleX -= 7;
        }

        x += dx;
        y += dy;
        }

        function startGame() {
            sndLoop.loop = true;
            sndLoop.play();
            interval = setInterval(draw, 10);
        }

        var video = document.getElementById("motivation");
        video.style.display = "none"

        function togglePause() {
            paused = !paused;
            if (!paused) {
                interval = setInterval(draw, 10); // Resume the game
            } else {
                clearInterval(interval); // Pause the game
            }

            //video.style.display = "block";
            //flashScreen();
        }

        function flashScreen()
        {
            canvas.style.display = "none";
            canvas2.style.display = "block";
            flashCount = 0;
            flashInterval = setInterval(() => {
                if (flashCount >= maxFlashes) {
                    clearInterval(flashInterval);
                    return;
                }
                if (flashCount % 2 === 0) {
                    ctx2.fillStyle = "black";
                } else {
                    ctx2.fillStyle = "white";
                }
                ctx2.fillRect(0, 0, canvas2.width, canvas2.height);
                flashCount++;
            }, 100);
        }

        function flashScreenDeath()
        {
            sndLoop.pause();
            sndFail.play();
            canvas.style.display = "none";
            canvas2.style.display = "block";
            gameEndP.style.display="block";
            flashCount = 0;
            flashInterval = setInterval(() => {
                if (flashCount >= maxFlashes) {
                    clearInterval(flashInterval);
                    return;
                }
                if (flashCount % 2 === 0) {
                    ctx2.fillStyle = "black";
                } else {
                    ctx2.fillStyle = "white";
                }
                ctx2.fillRect(0, 0, canvas2.width, canvas2.height);
                flashCount++;
            }, 100);
            endButtonB.style.display="block";
            //gameOver();
        }

        function gameOver()
        {
            alert("GAME OVER");
            document.location.reload();
            clearInterval(interval);
        }

        //Buttons-----------------------------------
        document.getElementById("runButton").addEventListener("click", function () {
        startGame();
        this.disabled = true;
        });

        document.getElementById("endButton").addEventListener("click", function () {
        gameOver();
        this.disabled = true;
        });
        //Buttons-----------------------------------


        //Shake Effect-----------------------------------
        function shakeCanvas(duration, intensity, canvasNum) 
        {
            const shakeAmount = intensity;
            const startTime = Date.now();

            function shake() {
                const elapsed = Date.now() - startTime;  //Counts time for shake runtime.
                if (elapsed < duration) {
                    const dx = (Math.random() * 2 - 1) * shakeAmount;
                    const dy = (Math.random() * 2 - 1) * shakeAmount;
                    canvasNum.style.transform = `translate(${dx}px, ${dy}px)`; //Translates dx and dy values into 'translate()'
                    requestAnimationFrame(shake);
                } else {
                    canvasNum.style.transform = 'translate(0px, 0px)'; //Return to normal.
                }
            }


            shake();
        }   
        //Shake Effect-----------------------------------

        function showEnterUserName()
        {
            enterNameLabel.style.display="block";
            enterName.style.display = "block";
        }

    </script>
  </body>
</html>
